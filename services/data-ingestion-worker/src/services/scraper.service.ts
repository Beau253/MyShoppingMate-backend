// Use puppeteer-extra and the stealth plugin to avoid bot detection.
import puppeteer from 'puppeteer-extra';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';
import { Browser, Page, HTTPResponse } from 'puppeteer'; // Import HTTPResponse for typing
puppeteer.use(StealthPlugin());

const USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36';
const SEARCH_API_URL = 'https://www.woolworths.com.au/apis/ui/Search/products';
const COLES_SEARCH_API_URL = 'https://www.coles.com.au/api/bff/products/search';
const COLES_IMAGE_BASE_URL = 'https://productimages.coles.com.au/productimages'; // Base URL for constructing full image paths

// A unified data model for a product, regardless of the source.
interface Product {
  gtin: string;
  name: string;
  brand: string;
  price: number;
  imageUrl: string;
  size: string;
  store: 'Woolworths' | 'Coles';
  categories: string[];
}

// Interface for the filter structure the API expects.
export interface WoolworthsFilter {
  Key: string;
  Items: { Term: string }[];
}

// Type for the raw data we'll pull from the browser
interface RawScrapedData {
  products: any[];
  aggregations: any[];
  facetFilters: string[];
}

// --- INTELLIGENCE LAYER: DYNAMIC CATEGORIZATION ---

/**
 * Creates a map of categories to search keywords, based on the API's own suggestions.
 * This is the core of the dynamic approach.
 * @param aggregations - The 'Aggregations' array from the API.
 * @param facetFilters - The 'FacetFilters' array from the API.
 * @returns A Map where keys are official categories and values are arrays of keywords to search for.
 */
function buildCategoryKeywordMap(aggregations: any[], facetFilters: string[]): Map<string, string[]> {
  const categoryMap = new Map<string, string[]>();
  const knownSynonyms: { [key: string]: string[] } = {
    'Full Fat': ['full fat', 'full cream', 'whole milk'],
    // Add more known synonyms here for other product types as needed.
  };

  const allFilterTerms = new Set<string>(facetFilters);

  // Extract terms from key aggregations
  const relevantAggregations = ['Allergens', 'Lifestyle'];
  aggregations.forEach(agg => {
    if (relevantAggregations.includes(agg.Name) && agg.ResultsGrouped) {
      agg.ResultsGrouped.forEach((group: any) => {
        group.Filters.forEach((filter: any) => allFilterTerms.add(filter.Name));
      });
    }
  });

  // Build the final map
  allFilterTerms.forEach(term => {
    const keywords = knownSynonyms[term] || [term.toLowerCase()];
    categoryMap.set(term, keywords);
  });

  return categoryMap;
}

/**
 * Assigns categories to a single product by checking its data against the keyword map.
 * @param product - The raw product object from the API.
 * @param categoryMap - The map generated by buildCategoryKeywordMap.
 * @returns An array of matching category strings.
 */
function assignCategoriesToProduct(product: any, categoryMap: Map<string, string[]>): string[] {
  const assignedCategories = new Set<string>();

  // Consolidate all searchable text fields from the product into one string.
  const searchableText = [
    product.DisplayName,
    product.AdditionalAttributes?.description,
    product.AdditionalAttributes?.sapsegmentname,
    product.AdditionalAttributes?.piessubcategorynamesjson,
    product.AdditionalAttributes?.lifestyleanddietarystatement,
    product.AdditionalAttributes?.allergystatement,
  ]
    .join(' ')
    .toLowerCase();

  // Iterate through our dynamic list of possible categories
  for (const [category, keywords] of categoryMap.entries()) {
    // Check if any of the keywords for this category exist in the product's text
    for (const keyword of keywords) {
      if (searchableText.includes(keyword)) {
        assignedCategories.add(category);
        break; // Move to the next category once one keyword matches
      }
    }
  }

  // --- Contradiction Resolution ---
  // If a product is categorized as both Low Fat and Full Fat, use the product name as the tie-breaker.
  if (assignedCategories.has('Low Fat') && assignedCategories.has('Full Fat')) {
    const productName = (product.DisplayName || '').toLowerCase();
    if (productName.includes('low fat') || productName.includes('skim') || productName.includes('lite')) {
      assignedCategories.delete('Full Fat'); // It's definitely a low-fat product.
    }
  }

  return Array.from(assignedCategories);
}

/**
 * Scrapes Coles products using a headless browser to handle the Imperva WAF.
 * It navigates to the search page and intercepts the JSON response from the BFF API.
 */
async function scrapeColesAPI(query: string): Promise<Product[]> {
  let browser: Browser | null = null;
  const allProducts: Product[] = [];
  console.log(`[ScraperService] Launching browser for Coles query: "${query}"`);

  try {
    browser = await puppeteer.launch({
      // Run headful (with a GUI) in dev, and headless in production
      headless: process.env.NODE_ENV === 'production',
      dumpio: false,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--no-zygote' // Adds further stability in some container environments.
      ],
    });
    console.log('[ScraperService] Browser launched successfully.');

    const page = await browser.newPage();
    console.log('[ScraperService] New page created.');
    await page.setUserAgent(USER_AGENT);
    await page.setViewport({ width: 1920, height: 1080 });
    console.log('[ScraperService] User agent and viewport set.');

    // Handle Cookie Consent Banner
    // This is a crucial step. Many sites won't load full content until cookies are accepted.
    try {
      console.log('[ScraperService] Navigating to Coles homepage to handle cookie consent...');
      await page.goto('https://www.coles.com.au', { waitUntil: 'domcontentloaded', timeout: 30000 });
      const acceptButtonSelector = 'button#onetrust-accept-btn-handler';
      await page.waitForSelector(acceptButtonSelector, { timeout: 10000 }); // Wait up to 10s
      await page.click(acceptButtonSelector);
      console.log('[ScraperService] Cookie consent accepted.');
      // Wait a moment for the page to process the click
      await new Promise(res => setTimeout(res, 2000));
    } catch (e) {
      console.log('[ScraperService] Cookie consent banner not found or already handled. Continuing...');
    }

    let hasMorePages = true;
    let pageNumber = 1;

    // This selector targets the "No results" message on the Coles website.
    const noResultsSelector = '[data-testid="search-no-results"]';

    while (hasMorePages) {
      console.log(`[ScraperService] Navigating to Coles search page ${pageNumber} for query: "${query}"`);
      const searchUrl = `https://www.coles.com.au/en/search?q=${encodeURIComponent(query)}&page=${pageNumber}`;

      // --- NEW: Promise.race IMPLEMENTATION ---

      // Promise 1: Waits for the API response
      const responsePromise = new Promise<any>((resolve, reject) => { //NOSONAR
        const requestHandler = async (response: HTTPResponse) => {
          if (response.url().startsWith(COLES_SEARCH_API_URL) && response.request().method() === 'GET') {
            page.off('response', requestHandler);
            console.log(`[ScraperService] Intercepted Coles API response.`);
            console.log('[ScraperService] Parsing API response JSON...');
            if (response.ok()) {
              resolve(await response.json());
            } else {
              reject(new Error(`Coles API responded with status ${response.status()}`));
            }
          }
        };
        page.on('response', requestHandler);
      });

      // Promise 2: Waits for the "No results" element to appear
      const noResultsPromise = page.waitForSelector(noResultsSelector, { timeout: 30000 })
        .then(() => {
            console.log('[ScraperService] "No results" element found on page.');
            // We resolve with a specific value to identify that this promise won.
            return { noResults: true }; 
        });

      // Start navigation
      await page.goto(searchUrl, { waitUntil: 'domcontentloaded', timeout: 30000 });

      // Race the two promises. Whichever finishes first wins.
      const raceResult = await Promise.race([responsePromise, noResultsPromise]);
      console.log('[ScraperService] Page navigation and data interception complete.');

      if (raceResult.noResults) {
        console.log('[ScraperService] No more products found. Ending pagination.');
        hasMorePages = false;
        continue;
      }
      
      const data = raceResult;
      const results = data.results || [];
      console.log(`[ScraperService] Found ${results.length} items on page ${pageNumber}.`);

      if (results.length === 0 || results.length < 48) {
        hasMorePages = false;
        console.log(`[ScraperService] This is the last page of results.`);
      }

      const mappedProducts: Product[] = results
        .filter((p: any) => p && p._type === 'PRODUCT') // Added a check for p to be truthy
        .filter((p: any) => p._type === 'PRODUCT')
        .map((product: any) => {
          const imageUrl = (product.imageUris && product.imageUris.length > 0)
              ? `${COLES_IMAGE_BASE_URL}${product.imageUris[0].uri}`
              : '';

          return {
            gtin: String(product.id || 'N/A'),
            name: product.name || 'N/A',
            brand: product.brand || 'N/A',
            price: product.pricing?.now || 0,
            imageUrl: imageUrl,
            size: product.size || 'N/A',
            store: 'Coles' as const,
            categories: [],
          };
      });

      console.log(`[ScraperService] Mapped ${mappedProducts.length} products from page ${pageNumber}.`);
      allProducts.push(...mappedProducts);
      pageNumber++;
    }

    console.log(`[ScraperService] Coles scraping complete. Total products: ${allProducts.length}.`);
    return allProducts;

  } catch (error) {
    const err = error as Error;
    console.error(`[ScraperService] An error occurred during Coles scraping: ${err.message}`);
    // Capture a screenshot on error for debugging. This is extremely helpful!
    if (browser) {
        const pages = await browser.pages();
        if (pages.length > 0) {
            await pages[0].screenshot({ path: 'coles_error_screenshot.png', fullPage: true });
            console.log('[ScraperService] Error screenshot saved to coles_error_screenshot.png');
        }
    }
    return allProducts;
  } finally {
    if (browser) {
      console.log('[ScraperService] Closing browser.');
      await browser.close();
    }
  }
}

/**
 * Main scraping function, now orchestrating a smarter, decoupled process.
 */
async function scrapeWoolworthsAPI(query: string, filters: WoolworthsFilter[] = []): Promise<Product[]> {
  let browser: Browser | null = null;
  const allEnrichedProducts: Product[] = [];
  console.log(`[ScraperService] Launching browser for query: "${query}" with ${filters.length} filters.`);

  try {
    browser = await puppeteer.launch({
      headless: true,
      dumpio: false,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
      ],
    });

    const browserPage = await browser.newPage();
    await browserPage.setUserAgent(USER_AGENT);
    await browserPage.setViewport({ width: 1920, height: 1080 });

    // Navigate to the homepage to establish a valid session with cookies.
    console.log('[ScraperService] Navigating to homepage to establish session...');
    await browserPage.goto('https://www.woolworths.com.au', { waitUntil: 'domcontentloaded' });

    let currentPage = 1;
    let hasMorePages = true;
    let previousPageGtins = new Set<string>();

    while (hasMorePages) {
      console.log(`[ScraperService] Scraping page ${currentPage}...`);
      const rawData: RawScrapedData = await browserPage.evaluate(
        (apiUrl, searchTerm, filterList, pageNum) => {
          return fetch(apiUrl, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              SearchTerm: searchTerm, PageNumber: pageNum, PageSize: 36, SortType: 'TraderRelevance', Filters: filterList,
            }),
          })
          .then(response => {
            if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
            return response.json();
          })
          .then(data => {
            const outerProducts = data.Products || [];
            const allInnerProducts: any[] = [];
            outerProducts.forEach((group: any) => {
              if (group && group.Products) allInnerProducts.push(...group.Products);
            });
            return {
              products: allInnerProducts,
              aggregations: data.Aggregations || [],
              facetFilters: data.FacetFilters || [],
            };
          });
        },
        SEARCH_API_URL, query, filters, currentPage
      );

      if (rawData.products.length === 0) {
        hasMorePages = false;
        console.log(`[ScraperService] Page ${currentPage} has no products. Ending pagination.`);
        continue;
      }

      // --- Duplicate Detection Logic ---
      // Check if the current page's products are the same as the last page's.
      const currentPageGtins = new Set(rawData.products.map(p => p.Barcode).filter(Boolean));
      if (currentPageGtins.size > 0 && Array.from(currentPageGtins).every(gtin => previousPageGtins.has(gtin))) {
        hasMorePages = false;
        console.log(`[ScraperService] Page ${currentPage} contains only duplicate products. Ending pagination.`);
        continue;
      }

      // If we have new products, update the set for the next iteration.
      if (currentPageGtins.size > 0) {
        previousPageGtins = currentPageGtins;
      }

      console.log(`[ScraperService] Scraped ${rawData.products.length} raw products from page ${currentPage}. Now processing...`);

      const categoryMap = buildCategoryKeywordMap(rawData.aggregations, rawData.facetFilters);

      const enrichedProducts: Product[] = rawData.products.map(product => {
        return {
          gtin: product.Barcode || 'N/A',
          name: product.DisplayName,
          brand: product.Brand || 'N/A',
          price: product.Price,
          imageUrl: product.MediumImageFile,
          size: product.PackageSize,
          store: 'Woolworths' as const,
          categories: assignCategoriesToProduct(product, categoryMap),
        };
      });

      allEnrichedProducts.push(...enrichedProducts);
      currentPage++;
    }

    console.log(`[ScraperService] Pagination complete. Total enriched products: ${allEnrichedProducts.length}.`);
    return allEnrichedProducts;

  } catch (error) {
    const err = error as Error;
    console.error(`[ScraperService] An error occurred: ${err.message}`);
    return allEnrichedProducts; // Return whatever was scraped before the error.
  } finally {
    if (browser) {
      console.log('[ScraperService] Closing browser.');
      await browser.close();
    }
  }
}

export const scraperService = {
  // Update the main scrape function to accept filters
  scrape: (target: string, query: string, filters?: WoolworthsFilter[]) => {
    switch (target.toLowerCase()) {
      case 'woolworths':
        return scrapeWoolworthsAPI(query, filters);
      case 'coles':
        return scrapeColesAPI(query);
      default:
        console.warn(`[ScraperService] No scraper found for target: ${target}`);
        return Promise.resolve([]);
    }
  }
};